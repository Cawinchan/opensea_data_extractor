import json
from io import BytesIO
import shutil
from reportlab.graphics.shapes import Shape
import requests
from PIL import Image
import mimetypes
import urllib.request
import os
import logging
from matplotlib import image
import pandas as pd
import numpy as np
import glob 
from moviepy.editor import VideoFileClip
from svglib.svglib import svg2rlg
from reportlab.graphics import renderPM
from pydub import AudioSegment
import subprocess

from shutil import copyfile
# from cairosvg import svg2pngs

import sys
# ROOT_DIRECTORY = '/home/princeton/Documents/GitHub/project_numpie'
# sys.path.append(ROOT_DIRECTORY)
from opensea_local import *

from opensea_local.models.asset import Asset
from src.nft_collection import nft_format, TOTAL_FORMATS

logging.basicConfig(filename='example.log', level=logging.DEBUG)

def has_audio(filename):
    ''' Finds if video has audio present 

    Output: True or False

    How to install ffprobe on windows, https://www.wikihow.com/Install-FFmpeg-on-Windows 
    FFmpeg contains ffprobe
    
    '''
    result = subprocess.run(["ffprobe", "-v", "error", "-show_entries",
                             "format=nb_streams", "-of",
                             "default=noprint_wrappers=1:nokey=1", filename],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT)
    # result outputs whether we have 2 streams(frames + audio) or 1 stream(frames) of data, therefore if 2, it is true
    return int(result.stdout) == 2

def sanatise_text(text):
    ''' Removes all non-ASCII characters and 

    replaces end of line (eol) (\\n) with space (" ")  
    replace raw string (\\r) with space 
    replace unicode string (\\u) with space 

    
    Output: santised text
    
    '''
    if type(text) == str:
        non_ascii_text = text.encode('ascii', 'ignore').decode()
        non_ascii_text_removed = " ".join(non_ascii_text.strip().split())
        return non_ascii_text_removed
    return text

def extract_media(dir="data/raw/json",output_json_dir="data/preprocessed/json",output_media_dir="data/preprocessed/media"):    
    # Iterate over files in directory
    ''' NFT Metadata attributes
    {
        "RID": "1234", # Generated by us through files order 
        "name": "NFT Name", 
        "description": "NFT Description",
        "collection_name": "Collection Name",
        "collection_description": "Collection Description",
        "eth_price": 9000000000000000000,
        "eth_price_decimal": 18,
        "usd_price": 1200.89, # Closing Price of USD for that day
        "eth_volume": 674188.0,
        "eth_marketcap": 45486894.2408,
        "transaction_time": "2021-07-23T10:16:28",
        "media_filenames": ["1234.mp4", "1234.mp3"],
        "has_audio_in_video": false,
    }
    
    '''
    test_lst = [
    'async-music_96.txt', # 0
    'boonjiproject_230.txt', # 1
    'boredapeyachtclub_31.txt', # 2 
    'cryptopunks_1440.txt', # 3 
    'doodles-official_567.txt', # 4
    'fidenza-by-tyler-hobbs_3000851.txt', # 5
    'lostpoets_2046.txt', # 6
    'theshiboshis_9727.txt', # 7
    'veefriends_59.txt', # 8
    'jinglebe-nft-collection_5.txt', # 9
    'niftysaxspheres_300.txt', # 10
    'spottiewifi_250.txt', # 11
    'eulerbeats_562674402050.txt', # 12
    'eulerbeats-enigma_1327145222656.txt', # 13
    'namewee4896-collection_95727740131771719711156352934881276380160273071938247065567437124903236534273.txt', # 14
    'song-a-day_27853175353995272517766450193869818424107874020190547876689048720805438947329.txt', # 15
    'superrare_4818.txt', # 16
    'rarible_15763.txt'# 17 
    'jinglebe-nft-collection_103.txt',
    'eulerbeats-enigma_4535620207105.txt'
    ]

    RID = 0
    print("number of files",len(os.listdir(dir)))

    # Create temp folders to ensure correctness
    tmp_json_dir = f"{output_json_dir}/tmp"    
    tmp_media_dir = f"{output_media_dir}/tmp"
     # Ensure ouput dir exists, else skip
    os.makedirs(output_json_dir,exist_ok=True)
    os.makedirs(output_media_dir,exist_ok=True)
    os.makedirs(tmp_media_dir,exist_ok=True)
    os.makedirs(tmp_json_dir,exist_ok=True)

    # Load ETH data 
    eth = pd.read_csv("data/preprocessed/coin_Ethereum.csv")
    eth['date'] = pd.to_datetime(eth['Date']).dt.date
    eth.drop_duplicates(subset =['date'],inplace=True)
    
    for filename in os.listdir(dir):
        f = os.path.join(dir, filename)
        # Checking if it is a file
        if os.path.isfile(f):
            print("looking through {} file_num: {}".format(f,RID))
            logging.debug("looking through {} file_num: {}".format(f,RID))
            collection_nft_name = str(filename.split("_")[0])
            nft_type_dict = nft_format.get(collection_nft_name)
            nft_type_formats = nft_type_dict.get("formats") # NFTs must fit to these formats before they are downloaded
            print(collection_nft_name,"has format", nft_type_dict)
            if not len(glob.glob(output_media_dir+"/"+str(RID)+"*")) >= 1 or not (len(glob.glob(output_json_dir+"/"+str(RID)+"*")) >= 1):
                with open(f, "r") as file:
                    asset = Asset(json.loads(file.read()))
                    # print("gate -1")

                    if asset.last_sale_symbol in ('ETH','WETH'): # Ensures that we only work with ETH, note that we will assume ETH == WETH 
                        # Find Image/Animation assets step
                        json_download = False
                        image_download = False 
                        animation_download = False
                        media_filenames = []
                        has_audio_in_video = False
                        try:
                            image_url = asset.image_original_url
                            print("gate -1.2")
                            image_response = requests.get(image_url,timeout=10)
                            print("gate -1.4")
                            content_type = image_response.headers['content-type']
                            print("gate -1.6")
                            image_extension = mimetypes.guess_extension(content_type)
                            print("gate -2")

                            if image_extension == '.jpe':
                                image_extension = '.jpg'
                            if image_extension in ('.svg','.png') and '.jpg' in nft_type_formats: # We guarentee that every coversion must be usablen. We accept images, however, it is currently in the wrong format
                                # saves to tmp folder
                                try:    
                                    with open("{}/{}{}".format(tmp_media_dir,RID,image_extension), 'wb') as f:
                                        f.write(image_response.content)
                                except: 
                                    try: # Alternative way to get data
                                        urllib.request.urlretrieve(image_url, "{}/{}{}".format(tmp_media_dir,RID,image_extension))  
                                    except:
                                        pass
                                if image_extension == '.svg':
                                    # saves to tmp folder
                                    drawing = svg2rlg("{}/{}{}".format(tmp_media_dir,RID,image_extension)) 
                                    renderPM.drawToFile(drawing, "{}/{}{}".format(tmp_media_dir,RID,".jpg"), fmt="JPG")
                                    image_download = True # tracks the download of jpg to tmp
                                if image_extension == '.png':
                                    # saves to tmp folder
                                    im1 = Image.open("{}/{}{}".format(tmp_media_dir,RID,image_extension)).convert('RGB')
                                    im1.save("{}/{}{}".format(tmp_media_dir,RID,".jpg"))
                                    image_download = True
                                image_extension = '.jpg'
                                media_filenames.append("{}/{}{}".format(tmp_media_dir,RID,image_extension))
                            print("gate -2.5",image_extension)
                            if image_extension not in nft_type_formats or image_extension == None:
                                raise Exception
                            print("gate -3")

                        except Exception:
                            try:
                                image_url = asset.image_url
                                image_response = requests.get(image_url,timeout=10)
                                content_type = image_response.headers['content-type']
                                image_extension = mimetypes.guess_extension(content_type)
                                if image_extension == '.jpe':
                                    image_extension = '.jpg'
                                if image_extension in ('.svg','.png') and '.jpg' in nft_type_formats:
                                    try:    
                                        with open("{}/{}{}".format(tmp_media_dir,RID,image_extension), 'wb') as f:
                                            f.write(image_response.content)
                                    except: 
                                        try:
                                            urllib.request.urlretrieve(image_url, "{}/{}{}".format(tmp_media_dir,RID,image_extension)) 
                                        except:
                                            pass
                                    if image_extension == '.svg':
                                        drawing = svg2rlg("{}/{}{}".format(tmp_media_dir,RID,image_extension))
                                        renderPM.drawToFile(drawing, "{}/{}{}".format(tmp_media_dir,RID,".jpg"), fmt="JPG")
                                        image_download = True

                                    if image_extension == '.png':
                                        im1 = Image.open("{}/{}{}".format(tmp_media_dir,RID,image_extension))
                                        im1.save("{}/{}{}".format(tmp_media_dir,RID,".jpg"))
                                        image_download = True
                                    image_extension = '.jpg'
                                    media_filenames.append("{}/{}{}".format(tmp_media_dir,RID,image_extension))
                                if image_extension not in nft_type_formats or image_extension == None:
                                    raise Exception
                
                            except Exception as image_inst:
                                    image_extension = None
                                    logging.debug('{} was unable to get image, error: {}'.format(asset.image_url,image_inst))
                                    print(image_inst) 
                        print("gate 0")

                        try:
                            animation_url = asset.animation_original_url
                            animation_response = requests.get(animation_url,timeout=10)
                            content_type = animation_response.headers['content-type']
                            animation_extension = mimetypes.guess_extension(content_type)
                            if animation_extension == '.mp2':
                                animation_extension = '.mp3'
                            # Only other marketplaces can have all 4 types of files. As such we avoid converting all .mp4 formats to .mp3 in these marketplaces
                            if animation_extension in ('.mp4','.wav') and '.mp3' in nft_type_formats and len(nft_type_formats) != TOTAL_FORMATS:
                                try:    
                                    with open("{}/{}{}".format(tmp_media_dir,RID,animation_extension), 'wb') as f:
                                        f.write(animation_response.content)
                                except:
                                    try:
                                        urllib.request.urlretrieve(animation_url, "{}/{}{}".format(tmp_media_dir,RID,animation_extension)) 
                                    except:
                                        pass
                                if animation_extension == '.mp4':
                                    video = VideoFileClip("{}/{}{}".format(tmp_media_dir,RID,animation_extension))
                                    video.audio.write_audiofile("{}/{}{}".format(tmp_media_dir,RID,".mp3"))
                                    video.close()
                                if animation_extension == '.wav':
                                    AudioSegment.from_wav("{}/{}{}".format(tmp_media_dir,RID,animation_extension)).export("{}/{}{}".format(tmp_media_dir,RID,".mp3"), format="mp3")
                                animation_download = True
                                animation_extension = '.mp3'
                                media_filenames.append("{}/{}{}".format(output_media_dir,RID,animation_extension))

                            if animation_extension not in nft_type_formats or animation_extension == None:
                                    raise Exception

                        except Exception as animation_inst:
                                try:
                                    animation_url = asset.animation_url
                                    animation_response = requests.get(animation_url,timeout=10)
                                    content_type = animation_response.headers['content-type']
                                    animation_extension = mimetypes.guess_extension(content_type)
                                    if animation_extension == '.mp2':
                                        animation_extension = '.mp3'
                                    if animation_extension == '.mp4' and '.mp3' in nft_type_formats and len(nft_type_formats) != TOTAL_FORMATS:
                                        try:    
                                            with open("{}/{}{}".format(tmp_media_dir,RID,animation_extension), 'wb') as f:
                                                f.write(animation_response.content)
                                        except:
                                            try:
                                                urllib.request.urlretrieve(animation_url, "{}/{}{}".format(tmp_media_dir,RID,animation_extension)) 
                                            except:
                                                pass
                                        video = VideoFileClip("{}/{}{}".format(tmp_media_dir,RID,animation_extension))
                                        video.audio.write_audiofile("{}/{}{}".format(tmp_media_dir,RID,".mp3")).close()
                                        animation_download = True
                                        animation_extension = '.mp3'
                                        media_filenames.append("{}/{}{}".format(output_media_dir,RID,animation_extension))
                                    if animation_extension not in nft_type_formats or animation_extension == None:
                                        raise Exception
                                except Exception as animation_inst:
                                        animation_extension = None
                                        logging.debug('{} was unable to be downloaded, error: {}'.format(asset.animation_url,animation_inst))
                                        print(animation_url,animation_inst) 
                        
                        # Download Image/Animation assets step
                        print("gate 1")
                        logging.debug('{},{}'.format(image_extension,animation_extension))
                        logging.debug('{},{}'.format(image_url,animation_url))

                        if image_extension and not image_download:
                            if image_extension in nft_type_formats:
                                try:    
                                    with open("{}/{}{}".format(tmp_media_dir,RID,image_extension), 'wb') as f:
                                        f.write(image_response.content)
                                    media_filenames.append("{}/{}{}".format(tmp_media_dir,RID,image_extension))
                                    image_download = True
                                except:
                                    try:
                                        urllib.request.urlretrieve(image_url, "{}/{}{}".format(tmp_media_dir,RID,image_extension)) 
                                        media_filenames.append("{}/{}{}".format(tmp_media_dir,RID,image_extension))
                                        image_download = True
                                    except:
                                        print("Error downloading {} {} image {} extension".format(RID,image_url,image_extension))
                                        logging.debug("Error downloading {} {} image {} extension".format(RID,image_url,image_extension))

                        print("gate 2")

                        if animation_extension and not animation_download:
                            if animation_extension in nft_type_formats:
                                try:    
                                    with open("{}/{}{}".format(tmp_media_dir,RID,animation_extension), 'wb') as f:
                                        f.write(animation_response.content)
                                    media_filenames.append("{}/{}{}".format(tmp_media_dir,RID,animation_extension))
                                    animation_download = True
                                except:
                                    try:
                                        urllib.request.urlretrieve(animation_url, "{}/{}{}".format(tmp_media_dir,RID,animation_extension)) 
                                        media_filenames.append("{}/{}{}".format(tmp_media_dir,RID,animation_extension))
                                        animation_download = True
                                    except:
                                        print("Error downloading {} {} animation {} extension".format(RID,animation_url,animation_extension))
                                        logging.debug("Error downloading {} {} image {} extension".format(RID,image_url,image_extension))
                        if animation_download:
                            if animation_extension == ".mp4":
                                has_audio_in_video = has_audio("{}/{}{}".format(tmp_media_dir,RID,animation_extension))
                        print("gate 3")

                        # Create Json Metadata
                        json_metadata = {}
                        name = None
                        description = None
                        collection_name = None
                        collection_description = None
                        eth_price = None
                        eth_price_decimal = None
                        transaction_time = None
                        usd_price = None
                        usd_volume = None
                        usd_marketcap = None

                        # Find NFT Textual Data
                        try: 
                            if collection_nft_name == 'boredapeyachtclub':
                                name = "#"+asset.token_id    
                            else:
                                name = sanatise_text(asset.name)
                            description = sanatise_text(asset.description)
                            print(asset.collection_name,asset.collection_description)
                            collection_name = sanatise_text(asset.collection_name)
                            collection_description = sanatise_text(asset.collection_description)
                        except Exception as asset_data_inst:
                            logging.debug('Unable to get asset_textual_data, error: {}'.format(asset_data_inst))
                            print('Unable to get asset_textual_data',asset_data_inst) 
                        print("gate 4")

                        # Find NFT last sales data
                        try: 
                            eth_price = asset.last_sale
                            eth_price_decimal = asset.last_sale_decimals
                            transaction_time = asset.sale_timestamp
                            transaction_date = pd.Timestamp(transaction_time).date()
                            temp_eth_row = eth[['date','Close','Volume','Marketcap']].loc[eth['date'] == transaction_date]
                            if len(temp_eth_row) == 1: # Sanity check
                                usd_price = temp_eth_row['Close'].values[0] # Price of eth on the day of last sale
                                usd_volume = temp_eth_row['Volume'].values[0] 
                                usd_marketcap = temp_eth_row['Marketcap'].values[0] 
                        except Exception as asset_data_inst:
                            logging.debug('Unable to get asset_last_sales_data, error: {}'.format(asset_data_inst))
                            print('Unable to get asset_last_sales_data, error: {}'.format(asset_data_inst)) 

                        json_metadata['name'] = name
                        json_metadata['description'] = description
                        json_metadata['collection_name'] = collection_name
                        json_metadata['collection_description'] = collection_description
                        json_metadata['eth_price'] = eth_price
                        json_metadata['eth_price_decimal'] = eth_price_decimal
                        json_metadata['usd_price'] = usd_price
                        json_metadata['usd_volume'] = usd_volume
                        json_metadata['usd_marketcap'] = usd_marketcap
                        json_metadata['transaction_time'] = transaction_time
                        json_metadata['media_filenames'] = media_filenames
                        json_metadata['has_audio_in_video'] = has_audio_in_video

                        if len(json_metadata) == 12 and (image_download or animation_download): # checks if we have all our columns and downloaded a media
                            with open("{}/{}{}".format(tmp_json_dir,RID,'.json'), 'w') as f:
                                json.dump(json_metadata, f)
                            json_download = True
                        else:
                            print("Error with creating json, missing parameters", name , description , collection_name , collection_description \
                            , eth_price , eth_price_decimal , usd_price , usd_volume , usd_marketcap , transaction_time \
                            , media_filenames , has_audio_in_video)    

                        print("gate 5")
                        
                        if (image_download or animation_download) and json_download and len(media_filenames) == len(nft_type_formats): # Ensures that we have the required number of files expected 
                                # Download our json to folder and image and/or animation to folder
                                if image_download:
                                    copyfile("{}/{}{}".format(tmp_media_dir,RID,image_extension), "{}/{}{}".format(output_media_dir,RID,image_extension))
                                if animation_download:
                                    copyfile("{}/{}{}".format(tmp_media_dir,RID,animation_extension), "{}/{}{}".format(output_media_dir,RID,animation_extension))
                                copyfile("{}/{}{}".format(tmp_json_dir,RID,'.json'), "{}/{}{}".format(output_json_dir,RID,'.json'))
                                print("Successfully downloaded image and/or animation and json!")

                        elif (image_download or animation_download) and json_download and len(nft_type_formats) == TOTAL_FORMATS: # Handles our marketplaces where we have more possible formats 
                            if (image_download or animation_download) and json_download: # Ensures that we have the required number of files expected 
                                    # Download our json to folder and image and/or animation to folder
                                    if image_download:
                                        copyfile("{}/{}{}".format(tmp_media_dir,RID,image_extension), "{}/{}{}".format(output_media_dir,RID,image_extension))
                                    if animation_download:
                                        copyfile("{}/{}{}".format(tmp_media_dir,RID,animation_extension), "{}/{}{}".format(output_media_dir,RID,animation_extension))
                                    copyfile("{}/{}{}".format(tmp_json_dir,RID,'.json'), "{}/{}{}".format(output_json_dir,RID,'.json'))
                                    print("Successfully downloaded image and/or animation and json!")
                        else:
                            print(f"error image_download:{image_download},animation_download:{animation_download},json_download:{json_download},len(media_filenames):{len(media_filenames)}")
            else:
                print("file found! skipped")
            RID += 1 # Since our files are 1 json per NFT, we can enumerate through the list of "collection_name"_"token_id" as our Record ID (RID)
    # Clears our temp directory
    try:
        shutil.rmtree(tmp_media_dir)
        shutil.rmtree(tmp_json_dir)
    except Exception as e:
        print(e)

def check_lengths(output_json_dir="data/preprocessed/json",output_media_dir="data/preprocessed/media"):
    a = set(pd.DataFrame(os.listdir("data/preprocessed/json"))[0].str.replace(".json",""))
    b = set(pd.DataFrame(os.listdir("data/preprocessed/media"))[0].str[:-4])
    print(f"We have {len(a)} unique nfts")
    if not a.difference(b) and not b.difference(a):
        print("has no diff")
    else:
        print("has diff", a.difference(b),b.difference(a))
